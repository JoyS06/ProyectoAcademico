#include "AS5600.h"

#define IN1 12
#define IN2 13
#define PWM1 11
#define PWM2 10
#define IN3 8
#define IN4 9
#define ENCODER2 A0
AS5600 as5600;

// Variables para PID
double kp1 = 18, kd1 = 1.6, kp2 = 2.65 , kd2 = 0.1 ;

double input1, output1, input2, output2;
double lastError1 = 0, lastError2 = 0;


void setup() {
  Serial.begin(9600);
  Wire.begin();
  as5600.begin();
  // Config H bridge
  pinMode(PWM1, OUTPUT);
  pinMode(PWM2, OUTPUT);
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);
  //Serial.println("LABEL,Theta_1,t");
  delay(1000);
}

double offsetAngle1 = -150;
double offsetAngle2 = 332;
void PID(int setpoint1, int setpoint2) {
  input1 = offsetAngle1 - map(as5600.getCumulativePosition(), 0, 4095, 0, 360); // 12 Bits
  input2 = offsetAngle2 - map(analogRead(ENCODER2), 0, 1023, 0, 360);// 10 Bits, analog output
  double error1 = setpoint1 - input1; //erro motor 1
  double error2 = setpoint2 - input2; // error motor 2
  // motor 1 control
  double Pout1 = kp1 * error1; //
  double derivative1 = error1 - lastError1;
  double Dout1 = kd1 * derivative1; // salida motor 1
   // motor 2 control
  double Pout2 = kp2 * error2;
  double derivative2 = error2 - lastError2;
  double Dout2 = kd2 * derivative2;
  output2 = Pout2 + Dout2; // salida motor 2
  output1 = Pout1 + Dout1; // salida motor 1
  
  // INVERSION DE GIRO MOTOR 1
  if (output1 > 0) {
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, HIGH);
  } else {
    digitalWrite(IN1, HIGH);
    digitalWrite(IN2, LOW);
    output1 = -output1;
  }
  if (output2 > 0) {
    digitalWrite(IN3, LOW);
    digitalWrite(IN4, HIGH);
  } else {
    digitalWrite(IN3, HIGH);
    digitalWrite(IN4, LOW);
    output2 = -output2;
  }

  //LIMITACION PWM MOTOR 1
  if (output1 > 255) output1 = 255;
  if (output1 < 0) output1 = 0;
  //LIMITACION PWM MOTOR 2

  if (output2 > 255) output2 = 255;
  if (output2 < 0) output2 = 0; //Evita que se rompan los acoples
  
  //SALIDA PARA MOTOR 1
  analogWrite(PWM1, output1); // Enviar señal PWM al motor

  // SALIDA MOTOR 2
  analogWrite(PWM2, output2); // Enviar señal PWM al motor

  lastError1 = error1;
  lastError2 = error2;
  
}

double rad2Deg(double angle) {
  return round(angle * 180.0 / PI);
}

int steps = 75;
long milis = 0;
unsigned long currentmillis, Steptime;
long dt = 500;
double* angles;
int currentStep = 0;
double Scale = 1.33; //Se define hasta valores de 1.33
double Rotation = 0; // factor de rotacion en rotaciones
 //currentleafts
int steptime = 0;
double lastT1 = 0;
double lastT2 = 0;
double l1 = 23.1079;
double l2 = 14.1421;
double* getAngles (int step, double scale, double rotation, int leafts) {
  static double angles[2];
  int index = leafts - 3;
  double t = step * 2 * PI / steps;
  double sinusoidalFunction = scale * 3.06 * (sin(t * 3 + rotation) + 2);
  double x = sinusoidalFunction * cos(t) + 11;
  double y = sinusoidalFunction * sin(t) + 21.5;
  double cos2 = (x*x+y*y-l1*l1-l2*l2)/(2*l1*l2);
  angles[1] = atan2(sqrt(1-cos2*cos2),cos2);//Theta 2
  double sen1 = (l2*sin(angles[1]))/sqrt(x*x+y*y);
  angles[0] = atan2(y,x) - atan2(sen1, sqrt(1-sen1*sen1));//Theta 1

  return angles;
}

void loop() {
  currentmillis = millis();
  steptime = currentmillis - milis;
  if (steptime >= dt) {
    angles = getAngles(currentStep, Scale, Rotation, 3);
    milis = currentmillis;
    if (currentStep > 0) {
        Serial.println(currentStep - 1);
        Serial.print(lastT1);
        Serial.print(", ");
        Serial.println(lastT2);
        //Serial.println(output1);
    };
      currentStep++;
      if (currentStep >= steps) currentStep = steps;//Vuelve a empezar
      lastT1 = rad2Deg(angles[0]);
      lastT2 = rad2Deg(angles[1]);
  };
  PID(rad2Deg(angles[0]), rad2Deg(angles[1]));
}
